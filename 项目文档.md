### **ESP32-S3 商业级USB复合键盘项目文档**

#### 1. 项目概述

本项目是一个基于乐鑫ESP32-S3芯片和ESP-IDF框架的**商业级、可扩展的USB键盘**实现。它并非一个简单的入门示例，而是一个旨在实现功能丰富、可维护、可扩展的最终产品的专业固件架构。

项目的核心是利用`espressif/tinyusb`组件，将ESP32-S3实现为一个高度定制化的**USB复合设备**，同时具备多种HID（人机接口设备）功能。

**核心特性:**
- **USB复合设备**: 在单一USB连接上提供多种功能，包括：
    - 标准键盘 (6KRO)
    - 全键无冲键盘 (NKRO)
    - 消费级控制器（用于音量、播放等多媒体键）
    - RGB灯效控制器
- **专业硬件架构**: 按键输入通过**SPI总线**从外部专用扫描芯片获取，而非直接的GPIO扫描，这提升了性能和可扩展性。
- **模块化固件**: 遵循`开发指南.md`中详述的专业分层架构，将硬件驱动、USB通信、按键映射和功能特性解耦，便于维护和功能迭代。
- **生产级考量**: 架构设计中已为持久化配置存储(NVS)、动态宏、DFU固件更新等高级商业功能预留了接口。

#### 2. 核心技术与架构

##### 2.1. 软件栈: ESP-IDF + TinyUSB
项目明智地选择了直接使用`espressif/tinyusb`组件，而不是ESP-IDF提供的高级封装`esp_tinyusb`。这是因为要实现复合设备和高度定制化的HID报告描述符，必须直接访问底层的TinyUSB API，这为项目提供了最大的灵活性和控制力。

##### 2.2. 固件架构
遵循`开发指南.md`的设计哲学，项目采用了类似QMK/ZMK的专业分层架构，将固件划分为独立的组件：
- **`usb_driver` (本项目中的`hid_device`)**: 负责管理所有USB通信，包括描述符定义、TinyUSB任务初始化和HID报告的发送。
- **`matrix_scanner` (本项目中的`spi_scanner`)**: 硬件抽象层，专用于通过SPI与外部按键扫描芯片通信，并将物理按键事件（按下/释放）传递给上层。
- **`keymap_engine` (待实现)**: 逻辑核心，负责管理按键映射表、处理层切换，并将物理按键事件转换为具体的HID键码或功能码。
- **`features` (待实现)**: 功能扩展层，用于实现宏命令、RGB灯效控制、OLED显示等高级功能。

#### 3. 功能实现详解

##### 3.1. USB复合设备
项目的灵魂在于`hid_device/usb_descriptors.c`中定义的复合HID报告描述符。通过**报告ID (Report ID)**来区分不同的功能：
```c
// hid_device/usb_descriptors.c
uint8_t const desc_hid_report[] = {
    TUD_HID_REPORT_DESC_KEYBOARD(HID_REPORT_ID(REPORT_ID_KEYBOARD)),
    TUD_HID_REPORT_DESC_FULL_KEY_KEYBOARD(HID_REPORT_ID(REPORT_ID_FULL_KEY_KEYBOARD)),
    TUD_HID_REPORT_DESC_CONSUMER(HID_REPORT_ID(REPORT_ID_CONSUMER)),
    TUD_HID_REPORT_DESC_LIGHTING(HID_REPORT_ID(REPORT_ID_LIGHTING_LAMP_ARRAY_ATTRIBUTES))
};
```
当发送数据时，程序会使用`tud_hid_n_report()`并传入相应的`REPORT_ID`，主机就能正确解析数据包的用途（是普通按键，还是媒体键指令）。

##### 3.2. SPI按键输入
程序的入口`app_main`函数清晰地展示了工作流程的起点：
```c
// main/main.c
void app_main(void)
{
    spi_hid_init(); // 初始化SPI外设和USB驱动
    xTaskCreate(test_spi_task, "test_spi_task", 4096, NULL, 5, NULL); // 创建SPI扫描任务
}
```
`test_spi_task`任务会循环执行，通过SPI接口从扫描芯片读取按键状态，然后构建HID报告并通过USB发送出去。

##### 3.3. 详细工作流程：从硬件到USB报告的完整解析

项目的运行是基于FreeRTOS实时操作系统的多任务协作模型。核心是两个并行的关键任务：**USB协议栈任务**和**按键扫描与处理任务**。它们各司其职，通过事件和回调函数进行交互。以下是结合`spi_scanner.c`代码实现的完整流程：

**阶段一：启动与初始化**

1.  **上电与引导 (Power-On & Boot)**: ESP32-S3上电，片上Bootloader执行，加载Flash中的固件到内存，然后跳转到`app_main`函数开始执行用户代码。

2.  **进入`app_main`**: 程序在`main/main.c`中的`app_main`函数开始。

3.  **核心驱动初始化 (`spi_hid_init`)**: `app_main`首先调用`spi_hid_init()`，这个函数是系统所有功能启动的先决条件，它执行以下关键操作：
    *   **硬件初始化**: 配置并初始化SPI总线，为与外部按键扫描芯片（74HC165并行输入-串行输出移位寄存器）通信做准备。同时，初始化74HC165的并联加载引脚(SH/LD)，并将其默认置为高电平（移位模式）。
    *   **USB协议栈启动**: `spi_hid_init()`内部（或在`test_spi_task`首次运行时）会调用`tinyusb_hid_init()`。这一步会：
        *   根据`hid_device/tusb_config.h`的配置，初始化TinyUSB协议栈。
        *   设置USB OTG外设的物理层(PHY)，并准备好响应来自USB主机的信号。
        *   **最关键的是，`tinyusb_driver_install()`会自动创建一个高优先级的后台任务，专门用于循环调用`tud_task()`。** 这个任务是整个USB通信的心跳，我们称之为“USB任务”。

4.  **创建按键扫描任务**: `app_main`接着调用`xTaskCreate()`，创建`test_spi_task`。这是一个独立的、由我们自己控制的任务，负责处理所有与按键相关的逻辑。

**阶段二：USB枚举过程 (当设备插入PC时)**

这个过程完全由后台的“USB任务”(`tud_task()`)和我们预先定义好的回调函数自动处理，`test_spi_task`此时尚未参与。

1.  **主机请求**: PC检测到新的USB设备插入，开始通过控制端点0发送一系列`GET_DESCRIPTOR`请求，以了解这是什么设备。

2.  **`tud_task()`响应**: “USB任务”捕获到这些请求，并触发相应的回调函数（这些函数定义在`hid_device/usb_descriptors.c`中），返回设备描述符、配置描述符、字符串描述符以及最重要的**HID报告描述符**。

3.  **驱动加载与挂载**: 主机根据获取到的描述符信息，为其加载对应的驱动程序（通常是操作系统内置的通用HID驱动）。一旦驱动加载完成，设备就被成功“挂载”(Mounted)。

**阶段三：按键扫描任务 (`test_spi_task`) 的无限循环**

枚举成功后，`test_spi_task`在其`while(1)`循环中，以大约50Hz的频率（由`vTaskDelay(20)`决定）周而复始地执行以下**“扫描->滤波->映射->报告”**的流水线操作：

1.  **硬件扫描 (`read_74hc165_data`)**: 
    *   通过将SH/LD引脚拉低，触发所有连接在74HC165上的按键开关状态被并行“锁存”到寄存器内部。
    *   短暂延时后，将SH/LD引脚拉高，使74HC165进入“串行移位”模式。
    *   ESP32作为SPI主机，发起一次SPI传输。它不断产生时钟信号，从MISO引脚上逐位读取74HC165移位输出的数据。这些数据（代表了所有按键的原始通断状态）被存入`received_data`数组。

2.  **软件去抖 (`apply_debounce_filter`)**: 
    *   为了消除按键按下或释放瞬间的机械抖动（可能导致一次按键被误读为多次），程序执行一个简单的去抖动算法。
    *   它首先将第一次读取的`received_data`备份到`debounce_data`。
    *   然后等待一个极短的时间（代码中为100微秒）。
    *   再次调用`read_74hc165_data()`进行第二次采样。
    *   通过`XOR`和`OR`位运算，对两次读数进行比较和合并，以滤除抖动毛刺，得到一个稳定可靠的按键状态，并更新回`received_data`数组。

3.  **键码映射与报告构建 (`remap_keycode`)**: 这是流水线中最核心的逻辑处理步骤。
    *   **遍历状态**: 程序逐位检查去抖动后的`received_data`数组。如果某一位为1，代表对应按键被按下。
    *   **记录按键**: 将所有被按下的按键的物理索引号（0-16）记录下来。
    *   **查询映射表**: 遍历所有被按下的物理按键，使用它们的索引号去查询预定义的`keymaps`二维数组（当前代码固定查询第0层），找到其对应的逻辑功能，即**HID键码**（例如`KC_A`）或**修饰键**（例如`KC_LEFT_CTRL`）。
    *   **构建报告**: 
        *   **修饰键处理**: 如果查询到的是修饰键，则在一个8位的`modify`变量中，将对应的位置1。
        *   **普通键处理**: 如果是普通按键，则将其键码存入一个临时的`remap_data`数组中。
        *   **6KRO/NKRO决策**: 在处理完所有按键后，检查普通按键的数量。如果不多于6个，就构建一个标准的6键无冲（6KRO）HID报告；如果超过6个，则自动切换格式，构建一个能表示所有按键状态的全键无冲（NKRO）位图报告。

4.  **发送报告 (`tinyusb_hid_keyboard_report`)**: 
    *   将上一步构建完成的HID报告（无论是6KRO还是NKRO格式）传递给TinyUSB协议栈。
    *   后台的“USB任务”会接管这个报告，在合适的时机通过USB中断端点将其发送给主机。

5.  **延时与循环**: `test_spi_task`调用`vTaskDelay()`主动挂起20毫秒，让出CPU时间给其他任务（尤其是高优先级的“USB任务”），然后开始新一轮的“扫描->滤波->映射->报告”循环。

这个双任务并行、分工明确的架构，将对硬件的实时轮询与复杂的USB协议处理完全解耦，是构建高性能、高稳定性嵌入式系统的关键。

#### 4. 开发与部署

##### 4.1. 编译与烧录
编译和烧录流程与标准ESP-IDF项目相同。
1.  **配置**: `idf.py menuconfig`
2.  **编译**: `idf.py build`
3.  **烧录**: `idf.py -p <COM端口> flash`
4.  **监控**: `idf.py -p <COM端口> monitor`

##### 4.2. 固件更新 (DFU)
`开发指南.md`中详细说明了如何为产品进行固件更新，这是商业产品的必备功能。
1.  **创建DFU镜像**: `idf.py dfu`
2.  **进入DFU模式**: 按住`BOOT`键，再按一下`RESET`键。
3.  **烧录DFU**: `idf.py dfu-flash`
    - **注意**: Windows用户首次使用时，必须用**Zadig**工具为进入DFU模式后出现的设备安装`WinUSB`驱动。

##### 4.3. 调试
- **日志输出**: 推荐为复合设备增加一个CDC虚拟串口接口，通过`printf`直接从USB输出日志，极大方便调试。
- **底层分析**: 使用**Wireshark**配合`USBPcap`(Windows)或`usbmon`(Linux)可以捕获原始USB流量，是排查描述符错误和枚举问题的终极手段。

#### 5. 总结

本项目是一个高度专业、设计精良的商业级键盘固件基础。它采用了业界验证的成熟架构，具备高度的可扩展性和可维护性。开发者可以在此框架上，通过实现`keymap_engine`和在`features`目录中添加新功能，快速打造出一款功能强大、稳定可靠的定制化键盘产品。
